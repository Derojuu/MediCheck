  const [activeTab, setActiveTab] = useState<ManufacturerTab>("dashboard")
  const [searchQuery, setSearchQuery] = useState("")
  const [isCreateBatchOpen, setIsCreateBatchOpen] = useState(false)
  const [isTransferOpen, setIsTransferOpen] = useState(false)
  const [selectedBatch, setSelectedBatch] = useState<any>(null)
  const [batches, setBatches] = useState<any[]>([])
  const [products, setProducts] = useState<any[]>(mockProducts)
  const [organizations, setOrganizations] = useState<any[]>([])
  const [isLoadingMockaroo, setIsLoadingMockaroo] = useState(false)
  const [stats, setStats] = useState({
    totalBatches: 0,
    activeBatches: 0,
    pendingQuality: 0,
    recentTransfers: 0,
  })

  // Organization ID - in real app, this would come from auth context
  const organizationId = "org-1" // Manufacturer organization
  
  // Initialize Mockaroo service (using demo API key)
  const mockarooService = new MockarooService(process.env.NEXT_PUBLIC_MOCKAROO_API_KEY || 'demo-key')

  // Load real data from database on component mount
  useEffect(() => {
    const loadData = async () => {
      try {
        // Load batches
        const batchData = await getBatches(organizationId)
        setBatches(batchData)

        // Load stats
        const statsData = await getManufacturerStats(organizationId)
        setStats(statsData)
        
        // Load fresh data from Mockaroo API
        setIsLoadingMockaroo(true)
        try {
          const [mockarooProducts, mockarooOrganizations] = await Promise.all([
            mockarooService.generateProducts(6),
            mockarooService.generateOrganizations(8)
          ])
          
          // Convert Mockaroo organization data to our format
          const formattedOrgs = mockarooOrganizations.map((org, index) => ({
            id: `mockaroo-org-${index + 1}`,
            name: org.company_name,
            type: org.organization_type,
            location: `${org.city}, ${org.state}`,
            contactEmail: org.contact_email,
            contactPhone: org.contact_phone,
            contactPerson: org.contact_person,
            address: org.address,
            licenseNumber: org.license_number
          }))
          
          setOrganizations(formattedOrgs)
          console.log('âœ… Loaded fresh data from Mockaroo API:', { 
            products: mockarooProducts.length, 
            organizations: formattedOrgs.length 
          })
        } catch (mockarooError) {
          console.warn('âš ï¸ Mockaroo API failed, using fallback data')
          // Fallback to default organizations
          setOrganizations([
            { id: "1", name: "MediDistrib Lagos", type: "Distributor", location: "Lagos, Nigeria" },
            { id: "2", name: "HealthPlus Pharmacy", type: "Pharmacy", location: "Abuja, Nigeria" },
            { id: "3", name: "City Hospital Network", type: "Hospital", location: "Port Harcourt, Nigeria" },
            { id: "4", name: "Metro Pharmacy Chain", type: "Pharmacy", location: "Kano, Nigeria" },
            { id: "5", name: "Regional Medical Center", type: "Hospital", location: "Ibadan, Nigeria" },
          ])
        } finally {
          setIsLoadingMockaroo(false)
        }
      } catch (error) {
        console.error("Error loading data:", error)
        // Fallback to mock data if database fails
        setBatches(mockBatches)
        setStats({
          totalBatches: mockBatches.length,
          activeBatches: mockBatches.filter(b => b.status !== "DELIVERED").length,
          pendingQuality: mockBatches.filter(b => b.status === "MANUFACTURING").length,
          recentTransfers: 5,
        })
        // Set fallback organizations
        setOrganizations([
          { id: "1", name: "MediDistrib Lagos", type: "Distributor", location: "Lagos, Nigeria" },
          { id: "2", name: "HealthPlus Pharmacy", type: "Pharmacy", location: "Abuja, Nigeria" },
          { id: "3", name: "City Hospital Network", type: "Hospital", location: "Port Harcourt, Nigeria" },
        ])
        setIsLoadingMockaroo(false)
      }
    }
    loadData()
  }, [])

  // Load transfer history from localStorage (mock off-chain storage)
  const [transferHistory, setTransferHistory] = useState<any[]>([])
  
  useEffect(() => {
    const loadTransferHistory = () => {
      try {
        const stored = localStorage.getItem('transferHistory')
        if (stored) {
          setTransferHistory(JSON.parse(stored))
        }
      } catch (error) {
        console.error("Error loading transfer history:", error)
      }
    }
    loadTransferHistory()
  }, [])

  // New batch form state
  const [newBatch, setNewBatch] = useState({
    drugName: "",
    composition: "",
    batchSize: "",
    manufacturingDate: "",
    expiryDate: "",
    storageInstructions: "",
  })

  // Transfer form state
  const [transferForm, setTransferForm] = useState({
    toOrganization: "",
    transferReason: "",
    notes: "",
  })

  const recentTransfers = [
    {
      id: "T001",
      batchNumber: "PTC-2024-001",
      productName: "Paracetamol 500mg",
      fromEntity: "PharmaTech Industries",
      toEntity: "MediDistrib Lagos",
      quantity: 1500,
      transferDate: "2024-09-01",
      status: "Completed"
    },
    {
      id: "T002",
      batchNumber: "PTC-2024-003",
      productName: "Lisinopril 10mg", 
      fromEntity: "PharmaTech Industries",
      toEntity: "City Hospital Pharmacy",
      quantity: 3000,
      transferDate: "2024-08-30",
      status: "Completed"
    },
    {
      id: "T003",
      batchNumber: "PTC-2024-005",
      productName: "Aspirin 75mg",
      fromEntity: "PharmaTech Industries",
      toEntity: "HealthPlus Pharmacy",
      quantity: 5000,
      transferDate: "2024-09-02",
      status: "Pending"
    }
  ]

  const handleCreateBatch = async () => {
    try {
      if (!newBatch.drugName || !newBatch.batchSize || !newBatch.manufacturingDate || !newBatch.expiryDate) {
        alert("Please fill in all required fields")
        return
      }

      setIsLoadingMockaroo(true)
      
      try {
        // Generate realistic batch data using Mockaroo
        const mockarooBatches = await mockarooService.generateBatches(1)
        const mockarooBatch = mockarooBatches[0]
        
        console.log('ðŸ­ Generated batch data from Mockaroo:', mockarooBatch)
        
        // Create batch with enhanced Mockaroo integration
        const organizationId = "temp-org-id"
        const newBatchNumber = `PTC-2024-${String(batches.length + 1).padStart(3, '0')}`
        const selectedProduct = products.find(p => p.name === newBatch.drugName)
        
        const mockNewBatch = {
          batchId: newBatchNumber,
          drugName: newBatch.drugName,
          genericName: selectedProduct?.name || newBatch.drugName,
          composition: newBatch.composition || `${newBatch.drugName} with standard excipients`,
          batchSize: parseInt(newBatch.batchSize),
          manufacturingDate: new Date(newBatch.manufacturingDate),
          expiryDate: new Date(newBatch.expiryDate),
          storageInstructions: newBatch.storageInstructions || "Store at room temperature",
          currentLocation: mockarooBatch.current_location || "Production Facility - Line A",
          status: mockarooBatch.status === "In Production" ? "MANUFACTURING" : 
                 mockarooBatch.status === "Released" ? "READY_FOR_DISPATCH" : 
                 "MANUFACTURING" as const,
          qrCodeData: mockarooBatch.qr_code || `QR_${newBatchNumber.replace('-', '_')}_PENDING`,
          dosageForm: selectedProduct?.dosageForm || "Tablet",
          strength: selectedProduct?.strength || "N/A",
          createdAt: new Date(),
          updatedAt: new Date(),
          // Enhanced tracking data from Mockaroo
          transportTracking: {
            trackingNumber: `TRK-${Date.now()}`,
            estimatedDelivery: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
            currentGPS: `${6.5 + Math.random()}Â°N, ${3.3 + Math.random()}Â°E`, // Lagos area coordinates
            transportMethod: "Refrigerated Truck",
            route: `${mockarooBatch.current_location} â†’ Distribution Hub`,
            lastUpdate: new Date()
          }
        }

        setBatches([...batches, mockNewBatch])
        setStats(prev => ({ 
          ...prev, 
          totalBatches: prev.totalBatches + 1, 
          pendingQuality: prev.pendingQuality + 1 
        }))
        
        // Show enhanced success message with Mockaroo data
        alert(`âœ… Batch ${newBatchNumber} created successfully!

ðŸ­ Production Details:
â€¢ Batch ID: ${newBatchNumber}
â€¢ Location: ${mockNewBatch.currentLocation}
â€¢ QR Code: ${mockNewBatch.qrCodeData}
â€¢ Status: ${mockNewBatch.status}

ðŸšš Transport Ready:
â€¢ Tracking: ${mockNewBatch.transportTracking.trackingNumber}
â€¢ GPS Location: ${mockNewBatch.transportTracking.currentGPS}
â€¢ Transport Method: ${mockNewBatch.transportTracking.transportMethod}

Data generated using Mockaroo API for realistic pharmaceutical logistics.`)
        
      } catch (mockarooError) {
        console.warn('âš ï¸ Mockaroo batch generation failed, using standard batch creation')
        
        // Fallback to original batch creation
        const newBatchNumber = `PTC-2024-${String(batches.length + 1).padStart(3, '0')}`
        const selectedProduct = products.find(p => p.name === newBatch.drugName)
        
        const mockNewBatch = {
          batchId: newBatchNumber,
          drugName: newBatch.drugName,
          genericName: selectedProduct?.name || newBatch.drugName,
          composition: newBatch.composition || `${newBatch.drugName} with standard excipients`,
          batchSize: parseInt(newBatch.batchSize),
          manufacturingDate: new Date(newBatch.manufacturingDate),
          expiryDate: new Date(newBatch.expiryDate),
          storageInstructions: newBatch.storageInstructions || "Store at room temperature",
          currentLocation: "Production Facility",
          status: "MANUFACTURING" as const,
          qrCodeData: `QR_${newBatchNumber.replace('-', '_')}_PENDING`,
          dosageForm: selectedProduct?.dosageForm || "Tablet",
          strength: selectedProduct?.strength || "N/A",
          createdAt: new Date(),
          updatedAt: new Date()
        }

        setBatches([...batches, mockNewBatch])
        setStats(prev => ({ ...prev, totalBatches: prev.totalBatches + 1, pendingQuality: prev.pendingQuality + 1 }))
        alert(`Batch ${newBatchNumber} created successfully!`)
      }
      
      setIsCreateBatchOpen(false)
      setNewBatch({
        drugName: "",
        composition: "",
        batchSize: "",
        manufacturingDate: "",
        expiryDate: "",
        storageInstructions: "",
      })
    } catch (error) {
      console.error("Error creating batch:", error)
      alert("Error creating batch. Please try again.")
    } finally {
      setIsLoadingMockaroo(false)
    }
  }


  const getStatusColor = (status: string) => {
    switch (status) {
      case "READY_FOR_DISPATCH":
        return "default"
      case "MANUFACTURING":
        return "secondary"
      case "IN_TRANSIT":
        return "outline"
      case "DELIVERED":
        return "default"
      case "EXPIRED":
        return "destructive"
      default:
        return "secondary"
    }
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "READY_FOR_DISPATCH":
      case "DELIVERED":
        return <CheckCircle className="h-4 w-4" />
      case "MANUFACTURING":
      case "IN_TRANSIT":
        return <Clock className="h-4 w-4" />
      case "EXPIRED":
        return <XCircle className="h-4 w-4" />
      default:
        return <Clock className="h-4 w-4" />
    }
  }

  const getStatusDisplay = (status: string) => {
    switch (status) {
      case "READY_FOR_DISPATCH":
        return "Ready for Dispatch"
      case "MANUFACTURING":
        return "Manufacturing"
      case "IN_TRANSIT":
        return "In Transit"
      case "DELIVERED":
        return "Delivered"
      case "EXPIRED":
        return "Expired"
      default:
        return status
    }
  }

  const filteredBatches = batches.filter(batch =>
    batch.batchId.toLowerCase().includes(searchQuery.toLowerCase()) ||
    batch.drugName.toLowerCase().includes(searchQuery.toLowerCase())
  )